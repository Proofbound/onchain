<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ch01-earning-money-to-earning-circulation.zh – Global Business Chain</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-c1fac2584b48ed01fb6e278e36375074.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../assets/images/css/custom.css">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Global Business Chain</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../en/"> 
<span class="menu-text">English</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../zh/"> 
<span class="menu-text">简体中文</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../zh-tw/"> 
<span class="menu-text">繁體中文</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#sec-earning-circulation" id="toc-sec-earning-circulation" class="nav-link active" data-scroll-target="#sec-earning-circulation">從賺錢到賺流通</a>
  <ul class="collapse">
  <li><a href="#儲蓄經濟學的死亡" id="toc-儲蓄經濟學的死亡" class="nav-link" data-scroll-target="#儲蓄經濟學的死亡">儲蓄經濟學的死亡</a></li>
  <li><a href="#財富的流動狀態" id="toc-財富的流動狀態" class="nav-link" data-scroll-target="#財富的流動狀態">財富的流動狀態</a></li>
  <li><a href="#貨幣演變和信任機制" id="toc-貨幣演變和信任機制" class="nav-link" data-scroll-target="#貨幣演變和信任機制">貨幣演變和信任機制</a></li>
  <li><a href="#實踐中的流通優勢" id="toc-實踐中的流通優勢" class="nav-link" data-scroll-target="#實踐中的流通優勢">實踐中的流通優勢</a></li>
  <li><a href="#網路效應和價值創造" id="toc-網路效應和價值創造" class="nav-link" data-scroll-target="#網路效應和價值創造">網路效應和價值創造</a></li>
  <li><a href="#對經濟策略的影響" id="toc-對經濟策略的影響" class="nav-link" data-scroll-target="#對經濟策略的影響">對經濟策略的影響</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block"></header>




<section id="sec-earning-circulation" class="level1">
<h1>從賺錢到賺流通</h1>
<p>財富創造範式的根本轉變</p>
<p>「賺錢」這個概念在人類歷史中經歷了深刻的變革。在農業社會，財富意味著擁有能夠年復一年產出作物的肥沃土地。在工業革命期間，它演變為積累能夠大規模製造商品的資本和機械。在我們當前的數位時代，它經常被解釋為捕獲注意力並將其轉化為收入流。然而，在這些表面變化之下，有一個更深層的常數在所有時代都保持真實：真正的財富不是來自靜態積累，而是來自動態流動。</p>
<p>這一原則挑戰了現代經濟思維中最根深蒂固的假設之一。幾代人來，我們被教導財務安全來自儲蓄，將收入轉化為銀行存款、房地產持有或其他我們希望能夠保持或增加價值的儲存資產。這種基於儲存的財富創造方法在更穩定的經濟環境中是有意義的，但在我們當前貨幣擴張、通脹和快速變化的市場動態時代，它變得越來越成問題。</p>
<section id="儲蓄經濟學的死亡" class="level2">
<h2 class="anchored" data-anchor-id="儲蓄經濟學的死亡">儲蓄經濟學的死亡</h2>
<p>傳統的儲蓄策略在今天的經濟環境中面臨前所未有的挑戰。存放在儲蓄帳戶中的貨幣購買力隨著世界各地央行維持低利率的同時通過各種刺激措施增加貨幣供應量而穩步下降。這在實際意義上意味著今天儲蓄的錢明天的購買力會更少，對儲蓄者造成隱性稅收，隨著時間推移侵蝕財富。</p>
<p>考慮這種侵蝕的數學原理。如果通脹年運行率為3%，而儲蓄帳戶提供1%的利息，儲蓄資金的實際回報率每年為負2%。在十年期間，這種看似微小的差異會複合成購買力的重大損失。今天能夠購買一籃子商品的錢，十年後只能購買同樣商品的實質上更小的籃子。</p>
<p>這種現象不僅影響簡單的消費價格，還影響資產市場。房地產、股票和其他傳統價值儲存手段與其潛在經濟基本面越來越脫節，因為它們更多地作為過剩流動性的儲存庫而不是生產性投資。結果是一個系統，其中那些簡單儲蓄金錢的人進一步落後，而那些理解如何讓錢運動起來的人創造可持續的財富。</p>
<p>儲蓄方法對財富的處理也受到經濟學家稱之為機會成本的影響。閒置在低收益帳戶中的錢不能參與價值創造活動。它不能資助創新、支持成長中的企業，或促進產生真正繁榮的經濟交換。本質上，儲蓄心態將金錢視為目的本身，而不是作為促進人們之間有價值交換的工具。</p>
</section>
<section id="財富的流動狀態" class="level2">
<h2 class="anchored" data-anchor-id="財富的流動狀態">財富的流動狀態</h2>
<p>將財富理解為流動而不是積累需要視角的根本轉變。當金錢通過生產性管道流動時，它在每個交換點創造價值。花在教育上的一美元增加人力資本。投資於成長企業的一美元產生就業和創新。用於購買商品和服務的一美元傳達市場需求並支持創業精神。同樣的美元，當保持儲存狀態時，無法完成這些價值創造功能中的任何一個。</p>
<p>財富的流動狀態認識到金錢的真正力量在於其速度和方向，而不是其靜態數量。這一原則在我們相互連接的全球經濟中變得特別相關，其中價值創造越來越依賴於網路、關係和協作交換，而不是資源的孤立積累。</p>
<p>現代技術放大了基於流動的財富創造的重要性。數位平臺能夠跨越地理邊界和時區快速交換價值。加密貨幣和區塊鏈技術創造了追蹤和獎勵參與價值創造網路的新機制。這些發展指向經濟系統，其中促進和參與有價值交換的能力變得比積累和儲存資產的能力更重要。</p>
<p>流動方法也更好地與成功企業和企業家實際創造財富的方式保持一致。僅專注於囤積現金的公司往往變得停滯並失去市場地位給更具活力的競爭對手。將利潤再投資於增長機會的企業家通常超越那些簡單積累儲備的人。這種模式在個人、企業甚至國家經濟活動層面都是真實的。</p>
</section>
<section id="貨幣演變和信任機制" class="level2">
<h2 class="anchored" data-anchor-id="貨幣演變和信任機制">貨幣演變和信任機制</h2>
<p>貨幣本身的演變告訴了人類逐漸認識到流動比儲存更重要的故事。在最早的貨幣系統中，黃金和白銀作為價值儲存手段，正是因為它們耐用、可分割，並被廣泛接受用於交換。價值不是來自金屬本身，而是來自它們促進不同社區和時期之間貿易和商業的能力。</p>
<p>紙幣代表了下一個進化步驟，從物理商品抽象化，轉向由中央權威管理的基於信任的系統。紙幣的成功完全依賴於人們對它將在未來交換中被他人接受的信心。這標誌著從內在價值向網路效應和社會共識作為貨幣系統基礎的關鍵轉變。</p>
<p>數位貨幣和區塊鏈技術代表了這一進程中的另一個進化飛躍。與需要中央權威維持信任和促進交換的傳統貨幣不同，這些系統使用數學演算法和分散式共識機制來確保可靠性和安全性。信任不是來自機構保證，而是來自任何人都可以審計和參與的透明、可驗證過程。</p>
<p>這種演變揭示了一個一致的模式：最成功的貨幣系統是那些最好地促進交換和流通的系統，而不是那些擅長保存和儲存的系統。黃金是有價值的，因為它能夠跨越廣闊距離和時期進行貿易。紙幣成功是因為它使交換更高效和方便。數位貨幣正在獲得採用，因為它們能夠實現以前不可能或不實用的新形式價值交換。</p>
<p>每次轉變也減少了物理佔有的重要性，增加了網路參與的重要性。黃金需要物理保管和安全。紙幣需要機構信任和支持。數位貨幣需要網路參與和共識。這種趨勢始終遠離個人積累，轉向集體流通和交換。</p>
</section>
<section id="實踐中的流通優勢" class="level2">
<h2 class="anchored" data-anchor-id="實踐中的流通優勢">實踐中的流通優勢</h2>
<p>當檢查成功企業和個人實際如何建立和維持繁榮時，基於流通的財富創造的實際優勢變得明顯。像亞馬遜這樣的公司將幾乎所有利潤再投資於擴張、創新和改善客戶服務，而不是積累現金儲備。通過生產性活動的這種資源流通使他們能夠主導市場並為股東和客戶創造巨大價值。</p>
<p>擁抱流通原則的個人投資者往往超越那些專注於積累的人。他們不是簡單地購買和持有資產，而是積極尋求將資本投入價值創造活動的機會。這可能涉及投資教育和技能發展，支持成長中的企業，或參與新興市場機會。關鍵洞察是，投入良好選擇方向運動的金錢往往會倍增而不是僅僅保持價值。</p>
<p>流通優勢還延伸到個人財務管理。投資於自身能力、關係和機會的個人通常比那些簡單將錢存在傳統帳戶中的人建立更穩健和可持續的財富。這是因為人力資本、社會資本和智力資本都通過使用和發展而不是儲存和保存來升值。</p>
<p>此外，基於流通的方法在經濟混亂期間往往更具韌性。當市場快速變化時，儲存資產可能快速而決定性地失去價值。然而，投資於能力、關係和適應性系統的個人和企業往往能夠在挑戰性環境中找到創造價值的方法。他們的財富嵌入在流動和過程中而不是靜態資產中，使其對外部衝擊更具穩健性。</p>
</section>
<section id="網路效應和價值創造" class="level2">
<h2 class="anchored" data-anchor-id="網路效應和價值創造">網路效應和價值創造</h2>
<p>數位網路的出現通過創造通過參與和交換進行價值創造的新機制放大了流通優勢。社交媒體平臺、線上市場和協作軟體工具都從網路效應中獲得價值——隨著更多人參與其中，它們變得更有價值。這代表了從零和積累向正和流通和交換的根本轉變。</p>
<p>這些網路效應為個人通過促進有價值的網路而不是簡單積累資產來建設財富創造機會。內容創作者建立成為有價值資產的受眾。企業家創造連接買家和賣家的企業。投資者識別並支持早期階段有前途的網路效應。在每種情況下，財富創造來自促進和參與流通而不是提取和儲存價值。</p>
<p>這些影響超越純數位網路，涵蓋物理和社會網路。促進知識、資源和機會流通的社區往往比那些專注於保護和保存現有優勢的社區更繁榮。促進知識分享的教育機構超越那些限制訪問的機構。促進商業形成和協作的城市比那些優先保護現有結構的城市吸引更多投資和人才。</p>
</section>
<section id="對經濟策略的影響" class="level2">
<h2 class="anchored" data-anchor-id="對經濟策略的影響">對經濟策略的影響</h2>
<p>理解從賺錢到賺流通的轉變對個人、企業甚至政府如何處理經濟策略具有深遠影響。在個人層面，它建議專注於建設能力、關係和價值創造機會，而不是簡單積累儲蓄。這可能涉及投資教育，發展能夠參與有價值網路的技能，或創造促進他人之間交換的企業。</p>
<p>對於企業，基於流通的思維意味著專注於客戶價值創造、生態系統發展和網路效應的策略，而不是簡單的利潤提取和積累。幫助客戶成功、支持供應商增長並促進社區繁榮的公司往往比那些僅專注於最大化短期回報的公司建立更可持續的競爭優勢。</p>
<p>在政府層面，基於流通的經濟政策將強調促進生產性交換，減少價值創造障礙，支持有價值網路的發展，而不是簡單重新分配現有財富或保護既定行業。這可能涉及教育投資、基礎設施發展和鼓勵創新和創業精神的監管框架。</p>
<p>從基於儲存到基於流通的財富創造的轉變不僅僅是一個理論概念，而是我們快速發展的經濟環境中的實際必要性。那些適應這種新範式的人將發現自己在日益網路化和動態的世界中更好地定位來創造和維持繁榮。那些固守舊積累方法的人可能發現自己儘管努力儲蓄和保存財富卻落後了。</p>
<p>當我們在後續章節中探索基於流通商業的具體機制和應用時，特別是第2章中Web3技術的作用和第3章中鏈上商業的六大支柱，很明顯這種經濟思維的根本轉變不僅代表機會，而且是對21世紀價值創造現實的必要適應。</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Copyright 2025 Global Business Chain, Inc. <br> <a href="en/">English</a> | <a href="zh/">简体中文</a> | <a href="zh-tw/">繁體中文</a></p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>